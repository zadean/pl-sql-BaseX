create or replace package body basex_client
is
  ---------------------------------------------------------------------------
  -- Global query and result cache for iterating results.
  -- If more than one session is open, the query ids can collide and
  -- give unexpected results.
  ---------------------------------------------------------------------------
  type t_cache is table of clob index by pls_integer;
  type r_query is record
  (
    pos       number,
    res_cache t_cache
  );
  -- index by query id
  type t_query is table of r_query index by varchar2(25);
  g_query t_query;
  ---------------------------------------------------------------------------
  -- PRIVATE 
  ---------------------------------------------------------------------------
  function md5(str varchar2) return varchar2
  as
  begin
    return 
      lower(
        rawtohex(
          dbms_crypto.hash(utl_raw.cast_to_raw(str), dbms_crypto.HASH_MD5)
        )
      );
    exception
    when others then
      dbms_output.put_line(sqlerrm);
      raise;
  end;
  ---------------------------------------------------------------------------
  procedure write_to_wire(p_conn in out nocopy utl_tcp.connection, p_text clob)
  as
    l_dummy pls_integer;
    v_len   pls_integer;
  begin
    v_len := dbms_lob.getLength(p_text);
    if v_len > 32767 then
      declare
        buffer varchar2(4000);
        head   pls_integer := 1;
        chunk  pls_integer := 4000;
      begin
        while (head < v_len) loop
          dbms_lob.read(p_text, chunk, head, buffer);
          l_dummy := utl_tcp.write_text(p_conn, buffer);
          head := head + chunk;
        end loop;
      end;
    else
      l_dummy := utl_tcp.write_text(p_conn, p_text);
    end if;
  end;
  ---------------------------------------------------------------------------
  procedure write_to_wire(p_conn in out nocopy utl_tcp.connection, p_bin blob)
  as
    l_dummy pls_integer;
    v_len   pls_integer;
    buffer  raw(1000);
    head    pls_integer := 1;
    chunk   pls_integer := 1000;
  begin
    v_len := dbms_lob.getLength(p_bin);
    while (head < v_len) loop
      dbms_lob.read(p_bin, chunk, head, buffer);
      l_dummy := utl_tcp.write_raw(p_conn, buffer);
      head := head + chunk;
    end loop;
  end;
  ---------------------------------------------------------------------------
  function read_string(p_conn in out nocopy utl_tcp.connection) return clob
  as
    b         varchar2(1);
    buff      varchar2(32000) := '';
    clob_buff clob;
    sz        pls_integer := 0;
  begin
    -- success?
    if utl_tcp.get_text(c => p_conn, len => 1, peek => true) = chr(0) then
      return utl_tcp.get_text(c => p_conn, len => 1, peek => false);
    end if;
    -- wait until data is there, or timeout
    while (utl_tcp.available(p_conn, 0) > 0 and utl_tcp.get_text(c => p_conn, len => 1, peek => true) != chr(0))
    loop
      if sz = 32000 then
        clob_buff := clob_buff || buff;
        buff      := '';
        sz        := 0;
      end if;
      buff  := buff || utl_tcp.get_text(p_conn);
      sz    := sz +1;
    end loop;
    -- remove the 0 that kicked us out
    b := utl_tcp.get_text(c => p_conn, len => 1, peek => false);
    -- did we touch the clob?
    if clob_buff is null then
      return buff;
    else
      return clob_buff;
    end if;
  end;
  ---------------------------------------------------------------------------
  function read_binary(p_conn in out nocopy utl_tcp.connection) return blob
  as
    b         varchar2(1);
    blob_buff blob := null;
  begin
    dbms_lob.createtemporary(blob_buff,true);
    -- wait until data is there, or timeout
    while (utl_tcp.get_text(c => p_conn, len => 1, peek => true) != chr(0))
    loop
      dbms_lob.writeappend(blob_buff, 1, utl_tcp.get_raw(p_conn));
    end loop;
    -- remove the 0 that kicked us out
    b := utl_tcp.get_text(c => p_conn, len => 1, peek => false);
    return blob_buff;
  end;
  ---------------------------------------------------------------------------
  function ok(p_conn in out nocopy utl_tcp.connection) return boolean
  as
  begin
    return read_string(p_conn) like chr(0);
  end;
  ---------------------------------------------------------------------------
  procedure send_command(p_conn in out nocopy utl_tcp.connection, code pls_integer, arg varchar2, input clob)
  as
  begin
    write_to_wire(p_conn, chr(code) || arg || chr(0) || input || chr(0));
    g_info  := read_string(p_conn);
    if ok(p_conn) then
      null;
    else
      raise_application_error (-20002, 'Could not execute command.');
    end if;
  end;
  ---------------------------------------------------------------------------
  procedure send_command(p_conn in out nocopy utl_tcp.connection, code pls_integer, arg varchar2, input blob)
  as
  begin
    write_to_wire(p_conn, chr(code) || arg || chr(0));
    write_to_wire(p_conn, input);
    write_to_wire(p_conn, chr(0));
    g_info  := read_string(p_conn);
    if ok(p_conn) then
      null;
    else
      raise_application_error (-20002, 'Could not execute command.');
    end if;
  end;
  ---------------------------------------------------------------------------
  procedure send_void_command(p_conn in out nocopy utl_tcp.connection, p_command binary_integer, p_arg clob)
  as
  begin
    write_to_wire(p_conn, chr(p_command) || p_arg || chr(0));
  end;
  ---------------------------------------------------------------------------
  -- PUBLIC 
  ---------------------------------------------------------------------------
  function open_session(host varchar2, port number, username varchar2, pass varchar2) return utl_tcp.connection
  as
    v_conn   utl_tcp.connection;
    response varchar2(200);
    nonce    varchar2(16);
    code     varchar2(150);
    pos      binary_integer;
  begin
    -- get the connection
    v_conn    := utl_tcp.open_connection(remote_host => host, remote_port => port, charset => 'UTF8' ); --  tx_timeout => 1,
    response  := read_string(v_conn);
    pos       := instr(response,':');
    -- digest
    if pos    > -1 then
      code  := username || ':' || substr(response, 1, pos - 1) || ':' || pass;
      nonce := substr(response, pos + 1);
    -- md5
    else
      code  := pass;
      nonce := response;
    end if;
    -- send username and hashed password/timestamp
    write_to_wire(v_conn, username || chr(0) || md5(md5(code) || nonce) || chr(0));
    -- receive success flag
    if ok(v_conn) then
      return v_conn;
    else
      raise_application_error (-20001, 'Access denied.');
    end if;
  end;
  ---------------------------------------------------------------------------
  function bx_execute(p_conn  in out nocopy utl_tcp.connection, 
                      com                   varchar2) 
                      return clob
  as
    l_result clob;
  begin
    write_to_wire(p_conn, com || chr(0));
    l_result  := read_string(p_conn);
    g_info := read_string(p_conn);
    if ok(p_conn) then
      return l_result;
    else
      raise_application_error (-20002, 'Could not execute command. ' || g_info);
    end if;
  end;
  ---------------------------------------------------------------------------
  function bx_execute(p_conn  in out nocopy utl_tcp.connection, 
                      com                   varchar2,
                      is_binary             boolean) 
                      return blob
  as
    l_result blob;
  begin
    write_to_wire(p_conn, com || chr(0));
    l_result  := read_binary(p_conn);
    g_info := read_string(p_conn);
    if ok(p_conn) then
      return l_result;
    else
      raise_application_error (-20002, 'Could not execute command. ' || g_info);
    end if;
  end;
  ---------------------------------------------------------------------------
  procedure bx_create(p_conn  in out nocopy utl_tcp.connection, 
                      p_path                varchar2, 
                      p_input               clob)
  as
  begin
    send_command(p_conn, 8, p_path, p_input);
  end;
  ---------------------------------------------------------------------------
  procedure bx_add(p_conn in out nocopy utl_tcp.connection, 
                   p_path               varchar2, 
                   p_input              clob)
  as
  begin
    send_command(p_conn, 9, p_path, p_input);
  end;
  ---------------------------------------------------------------------------
  procedure bx_replace(p_conn in out nocopy utl_tcp.connection, 
                       p_path               varchar2, 
                       p_input              clob)
  as
  begin
    send_command(p_conn, 12, p_path, p_input);
  end;
  ---------------------------------------------------------------------------
  procedure bx_store(p_conn in out nocopy utl_tcp.connection, 
                     p_path               varchar2, 
                     p_input              blob)
  as
  begin
    send_command(p_conn, 13, p_path, p_input);
  end;
  ---------------------------------------------------------------------------
  function bx_info return clob
  as
  begin
    return g_info;
  end;
  ---------------------------------------------------------------------------
  procedure close_all_sessions
  as
  begin
    utl_tcp.close_all_connections;
  end;
  ---------------------------------------------------------------------------
  procedure close_session(p_conn in out nocopy utl_tcp.connection)
  as
  begin
    write_to_wire(p_conn, 'exit' || chr(0));  
    utl_tcp.close_connection(p_conn);
  end;
  ---------------------------------------------------------------------------
  -- PRIVATE Query functions
  ---------------------------------------------------------------------------
  function q_exec(p_conn in out nocopy utl_tcp.connection, p_command binary_integer, p_arg clob) return clob
  as
    retval clob;
  begin
    send_void_command(p_conn, p_command, p_arg);
    retval := read_string(p_conn);
    if ok(p_conn) then
      return retval;
    else
      raise_application_error (-20003, 'Unexpected result. ' || read_string(p_conn));
    end if;
  end;
  ---------------------------------------------------------------------------
  function q_exec(p_conn in out nocopy utl_tcp.connection, p_qid varchar2, p_command binary_integer, p_arg clob) return clob
  as
  begin
    return q_exec(p_conn, p_command, p_arg);
  end;
  ---------------------------------------------------------------------------
  procedure q_exec(p_conn in out nocopy utl_tcp.connection, p_command binary_integer, p_arg clob)
  as
    dummy clob;
  begin
    dummy := q_exec(p_conn, p_command, p_arg);
  end;
  ---------------------------------------------------------------------------
  procedure q_exec(p_conn in out nocopy utl_tcp.connection, p_qid varchar2, p_command binary_integer, p_arg clob)
  as
    dummy clob;
  begin
    dummy := q_exec(p_conn, p_command, p_arg);
  end;
  ---------------------------------------------------------------------------
  -- PUBLIC Query functions
  ---------------------------------------------------------------------------
  function bx_query(p_conn in out nocopy utl_tcp.connection, 
                    p_query              clob) 
                    return varchar2
  as
    l_id varchar2(25);
  begin
    l_id                    := q_exec(p_conn, 0, p_query);
    g_query(l_id).pos       := 0;
    g_query(l_id).res_cache.delete;
    return l_id;
  end;
  ---------------------------------------------------------------------------
  function q_more(p_conn in out nocopy utl_tcp.connection, 
                  p_qid  in out nocopy varchar2) 
                  return boolean
  as
  begin
    if g_query(p_qid).res_cache.count = 0 then
      send_void_command(p_conn, 4, p_qid);
      while (utl_tcp.get_text(c => p_conn, len => 1, peek => false) != chr(0))
      loop
        g_query(p_qid).res_cache(g_query(p_qid).res_cache.count + 1 ) := read_string(p_conn);
      end loop;
      if ok(p_conn) then
        null;
      else
        raise_application_error (-20003, read_string(p_conn));
      end if;
      g_query(p_qid).pos := 1;
    end if;
    if g_query(p_qid).pos <= g_query(p_qid).res_cache.count then
      return true;
    end if;
    g_query(p_qid).res_cache.delete;
    return false;
  end;
  ---------------------------------------------------------------------------
  function q_next(p_conn in out nocopy utl_tcp.connection, 
                  p_qid  in out nocopy varchar2) 
                  return clob
  as
    retval clob;
  begin
    if q_more(p_conn, p_qid) then
      retval := g_query(p_qid).res_cache(g_query(p_qid).pos);
      g_query(p_qid).res_cache(g_query(p_qid).pos) := null;
      g_query(p_qid).pos := g_query(p_qid).pos +1;
      return retval;
    else
      return null;
    end if;
  end;
  ---------------------------------------------------------------------------
  function q_execute(p_conn in out nocopy utl_tcp.connection, 
                     p_qid  in out nocopy varchar2) 
                     return clob
  as
  begin
    return q_exec(p_conn, p_qid, 5, p_qid);
  end;
  ---------------------------------------------------------------------------
  function q_info(p_conn in out nocopy utl_tcp.connection, 
                  p_qid  in out nocopy varchar2) 
                  return clob
  as
  begin
    return q_exec(p_conn, p_qid, 6, p_qid);
  end;
  ---------------------------------------------------------------------------
  function q_options(p_conn in out nocopy utl_tcp.connection, 
                     p_qid  in out nocopy varchar2) 
                     return clob
  as
  begin
    return q_exec(p_conn, p_qid, 7, p_qid);
  end;
  ---------------------------------------------------------------------------
  procedure q_bind(p_conn in out nocopy utl_tcp.connection, 
                   p_qid  in out nocopy varchar2, 
                   p_name               varchar2, 
                   p_value              clob)
  as
  begin
    q_bind(p_conn, p_qid, p_name, p_value, '');
  end;
  ---------------------------------------------------------------------------
  procedure q_bind(p_conn in out nocopy utl_tcp.connection, 
                   p_qid  in out nocopy varchar2, 
                   p_name               varchar2, 
                   p_value              clob, 
                   p_type               varchar2)
  as
  begin
    g_query(p_qid).res_cache.delete;
    q_exec(p_conn, p_qid, 3, p_qid || chr(0) || p_name || chr(0) || p_value || chr(0) || p_type);
  end;
  ---------------------------------------------------------------------------
  procedure q_context(p_conn in out nocopy utl_tcp.connection, 
                      p_qid  in out nocopy varchar2, 
                      p_value              clob)
  as
  begin
    q_context(p_conn, p_qid, p_value, '');
  end;
  ---------------------------------------------------------------------------
  procedure q_context(p_conn in out nocopy utl_tcp.connection, 
                      p_qid  in out nocopy varchar2, 
                      p_value              clob, 
                      p_type               varchar2)
  as
  begin
    g_query(p_qid).res_cache.delete;
    q_exec(p_conn, p_qid, 14, p_qid || chr(0) || p_value || chr(0) || p_type);
  end;
  ---------------------------------------------------------------------------
  procedure q_close(p_conn in out nocopy utl_tcp.connection, 
                    p_qid  in out nocopy varchar2)
  as
  begin
    q_exec(p_conn, p_qid, 2, p_qid);
  end;
  ---------------------------------------------------------------------------
end;
/
show errors